/* -*-mode: c-*- */
/*
 * Filename             : $RCSfile$
 *
 * Creation date  : 25-AUG-1997
 *
 * Created by           : Huub van der Wouden
 *
 * Company              : Transfer Solutions bv
 *
 * --- Description -------------------------------------------------------
 * EPC functionality that requires interaction with the Oracle database.
 *
 * --- Revision History --------------------------------------------------
 * $Log$
 * Revision 1.43  2004/10/15 20:41:32  gpaulissen
 * XML namespace bugs solved.
 *
 * Revision 1.42  2004/10/15 13:53:40  gpaulissen
 * XML added
 *
 * Revision 1.41  2004/05/21 15:07:51  gpaulissen
 * SOAP messages
 *
 * Revision 1.40  2004/03/29 07:23:26  gpaulissen
 * Only call epc.request_get_body when there is input
 *
 * Revision 1.39  2004/03/28 19:04:18  gpaulissen
 * null indicator toegevoegd voor output host arrays
 *
 * Revision 1.38  2004/03/28 15:32:25  gpaulissen
 * Generate C code only.
 *
 * Revision 1.37  2004/03/12 16:30:17  gpaulissen
 * 915081       The EPC idl compiler fails during build of the demo
 * 901781       CTRL-C kills EPC listener but not the session
 * 891761       -v option crashes
 * 699638       Empty connect string dumps core
 *
 * Revision 1.36  2004/03/07 10:43:06  gpaulissen
 * oneway bug with parameters solved
 *
 * Revision 1.35  2004/02/23 15:59:28  gpaulissen
 * sqlca is a member of epc_info structure
 *
 * Revision 1.34  2004/02/22 17:16:20  gpaulissen
 * interrupt_get_request_header added
 *
 * Revision 1.33  2003/08/19 15:55:57  gpaulissen
 * - enhanced searching for sqlplus
 * - enhanced signal handling
 * - make idl_y.h before idl_l.c
 *
 * Revision 1.32  2003/06/08 16:28:20  gpaulissen
 * GNU build system for ts_dbug
 *
 * Revision 1.31  2003/04/10 19:50:26  gpaulissen
 * Update
 *
 * Revision 1.30  2003/03/29 18:31:42  gpaulissen
 * Various fixes
 *
 * Revision 1.29  2003/03/26 21:47:06  gpaulissen
 * Building the epc
 *
 * Revision 1.28  2002/12/01 20:05:30  gpaulissen
 * Autoconf modifications
 *
 * Revision 1.27  2002/10/31 22:21:20  gpaulissen
 * Release 3.0.0a
 *
 * Revision 1.26  2002/01/17 11:46:53  gpaulissen
 * - Call to epc package updated due to changes.
 *
 * Revision 1.25  2001/01/24 16:29:08  gpaulissen
 * Release 2.0.0
 *
 * Revision 1.24  2000/08/14 13:47:39  gpaulissen
 * * Added -v command line option for version info.
 * * Updated build support.
 *
 * Revision 1.23  2000/07/07 12:14:55  gpaulissen
 * Release 1.6.3
 *
 * Revision 1.22  2000/01/13 16:23:24  gpaulissen
 * Version 1.6.0
 *
 * Revision 1.19  1999/11/25 09:15:17  gpaulissen
 * Release 1.5
 *
 * Revision 1.18  1999/11/23 16:05:30  gpaulissen
 * DBUG interface changed.
 *
 * Revision 1.17  1999/10/20 10:55:20  gpaulissen
 * Clean up return pipe when send fails.
 *
 * Revision 1.16  1999/08/26 12:34:54  gpaulissen
 * Added DBUG info
 *
 * Revision 1.15  1998/11/27 14:04:01  gjp
 * Added debugging.
 *
 * Revision 1.14  1998/08/19 06:35:49  gjp
 * Added epc_handle_request.
 *
 * Revision 1.13  1998/08/11 21:03:23  gjp
 * Modified comments.
 *
 * Revision 1.12  1998/07/31 16:23:04  gert-jan
 * Various changes.
 *
 # Revision 1.11  1998/07/27  15:18:54  gert-jan
 # First release.
 #
 * Revision 1.10  1998/05/26 11:06:13  gpauliss
 * Replaced RCS keyword Source by RCSfile
 *
 * Revision 1.9  1998/05/19 19:31:46  gpauliss
 * Used ANSI C syntax for EPC_handle_requests
 *
 * Revision 1.8  1998/05/06 20:20:12  gpauliss
 * Added support for longs
 *
 * Revision 1.7  1998/02/19 17:10:02  gpauliss
 * <>
 *
 * Revision 1.6  1998/02/19 17:05:22  gpauliss
 * Test
 *
 * Revision 1.5  1998/02/19 16:41:06  gpauliss
 * Using dos filename conventions (8.3)
 *
 * Revision 1.4  1998/02/17 20:26:59  gpauliss
 * Changed EPC interface
 *
 * Revision 1.3  1998/02/03 12:55:56  gpauliss
 * Modified EPC_handle_requests for return type and wrong fprintf.
 *
 * Revision 1.2  1998/02/03 09:59:22  gpauliss
 * - Free up memory when needed
 * - Changed message protocol
 * - Removed global use of sqlca structure
 * - Added full error checking
 *
 * Revision 1.1  1998/01/25 15:18:07  gpauliss
 * Initial revision
 *
 *
 */

#if HAVE_CONFIG_H
#include <config.h>
#endif

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC

/* defined on any system */
#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_SIGNAL_H
#include <signal.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_ASSERT_H
#include <assert.h>
#endif

/*#include <math.h>*/ /* GJP 25-06-2000
                         math.h gives compilation errors on Oracle 8.1.5 on Linux SuSE 6.3 */
#if HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#if HAVE_TIME_H
#include <time.h>
#endif

#endif

/* include sqlca.h even though it has been included already */
#ifdef SQLCA
#undef SQLCA
#endif

/* declare a structure */
#ifdef SQLCA_NONE 
#undef SQLCA_NONE 
#endif

#ifdef SQLCA_STORAGE_CLASS
#undef SQLCA_STORAGE_CLASS
#endif

/* a static sqlca only */
#define SQLCA_STORAGE_CLASS static

/* force initialisation of the static sqlca struct */
#ifndef SQLCA_INIT
#define SQLCA_INIT
#endif

EXEC SQL INCLUDE sqlca;

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include <epc_dbg.h>  /* trace and debug functionality */
#include <epc_xml.h>
#include <epc.h>
#endif

EXEC SQL BEGIN DECLARE SECTION;

EXEC SQL INCLUDE "epc_defs.h";  /* epc-specific type definitions */

EXEC SQL END DECLARE SECTION;

/* include dmalloc/ulib as last one */
#if defined(HASDMALLOC) && HASDMALLOC != 0
#include <dmalloc.h>
#elif defined(HASULIB) && HASULIB != 0
#include <u_alloc.h>
#endif

/* =====================================================================
 *
 * LOCAL DEFINITIONS
 *
 *======================================================================*/

/*
  [ 901781 ] CTRL-C kills EPC listener but not the session

  GJP 21-02-2004
  Both osnsui() and osncui() are hidden functions on Windows.
  However they seem to work exactly the same as on Unix platforms.
*/


/* user side interrupt set */
extern
dword_t
osnsui( dword_t *handlp, void (*astp)(epc_info_t *ctx), epc_info_t *ctx );
/*
** osnsui: Operating System dependent Network Set User-side Interrupt.
**         Add an interrupt handling procedure astp.
**         Whenever a user interrupt(such as a ^C) occurs, call astp
**         with argument ctx. Put in *handlp handle for this
**         handler so that it may be cleared with osncui.
**         Note that there may be many handlers; each should
**         be cleared using osncui. An error code is
**         returned if an error occurs.
*/

/* user side interrupt clear */
extern
dword_t
osncui( dword_t handle );
/*
** osncui: Operating System dependent Clear User-side Interrupt.
**         Clear the specified handler. The argument is the
**         handle obtained from osnsui. An error code is
**         returned if an error occurs.
*/


/*
  GJP 22-02-2004
  In order to be able to interrupt epc_srvr.recv_request()
  a different session (and a different context) is used.
  In a interrupt handler epc_srvr.send_request_interrupt()
  is invoked.
*/

EXEC SQL BEGIN DECLARE SECTION;
static sql_context interrupt_context;
EXEC SQL END DECLARE SECTION;

/* Can not supply epc_info to standard signal handlers 
   so supply a global */
static epc_info_t *interrupt_epc_info = NULL;

static
int
G_signo = 0;

static
void
handle_signal( int signo );

#define MAX_SIGNO 32

/* index 0 for startup, index 1 in signal handler */
static struct {
  void (*func)(int);
} signal_handler_info[2][MAX_SIGNO] = {
  {
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal },
    { handle_signal }
  },
  {
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN },
    { SIG_IGN }
  }
};

static
char *
signal_str( int signo )
{
  switch ( signo )
    {
#ifdef SIGHUP
    case SIGHUP: return "SIGHUP";
#endif
#ifdef SIGINT
    case SIGINT: return "SIGINT";
#endif
#ifdef SIGQUIT
    case SIGQUIT: return "SIGQUIT";
#endif
#ifdef SIGILL
    case SIGILL: return "SIGILL";
#endif
#ifdef SIGTRAP
    case SIGTRAP: return "SIGTRAP";
#endif
#ifdef SIGABRT
    case SIGABRT: return "SIGABRT";
#endif
#ifdef SIGEMT
    case SIGEMT: return "SIGEMT";
#endif
#ifdef SIGFPE
    case SIGFPE: return "SIGFPE";
#endif
#ifdef SIGBUS
    case SIGBUS: return "SIGBUS";
#endif
#ifdef SIGSEGV
    case SIGSEGV: return "SIGSEGV";
#endif
#ifdef SIGSYS
    case SIGSYS: return "SIGSYS";
#endif
#ifdef SIGPIPE
    case SIGPIPE: return "SIGPIPE";
#endif
#ifdef SIGALRM
    case SIGALRM: return "SIGALRM";
#endif
#ifdef SIGTERM
    case SIGTERM: return "SIGTERM";
#endif
#ifdef SIGURG
    case SIGURG: return "SIGURG";
#endif
#ifdef SIGSTOP
    case SIGSTOP: return "SIGSTOP";
#endif
#ifdef SIGTSTP
    case SIGTSTP: return "SIGTSTP";
#endif
#ifdef SIGCONT
    case SIGCONT: return "SIGCONT";
#endif
#ifdef SIGCHLD
    case SIGCHLD: return "SIGCHLD";
#endif
#ifdef SIGTTIN
    case SIGTTIN: return "SIGTTIN";
#endif
#ifdef SIGTTOU
    case SIGTTOU: return "SIGTTOU";
#endif
#ifdef SIGIO
    case SIGIO: return "SIGIO";
#endif
#ifdef SIGXCPU
    case SIGXCPU: return "SIGXCPU";
#endif
#ifdef SIGXFSZ
    case SIGXFSZ: return "SIGXFSZ";
#endif
#ifdef SIGVTALRM
    case SIGVTALRM: return "SIGVTALRM";
#endif
#ifdef SIGPROF
    case SIGPROF: return "SIGPROF";
#endif
#ifdef SIGWINCH
    case SIGWINCH: return "SIGWINCH";
#endif
#ifdef SIGLOST
    case SIGLOST: return "SIGLOST";
#endif
#ifdef SIGUSR1
    case SIGUSR1: return "SIGUSR1";
#endif
#ifdef SIGUSR2
    case SIGUSR2: return "SIGUSR2";
#endif
#ifdef SIGBREAK
    case SIGBREAK: return "SIGBREAK";
#endif
    default:
      return "Unknown signal";
    }
  return NULL;
}

static
void
set_signal_handlers( const int idx )
{
  int nr;

  DBUG_ENTER( "set_signal_handlers" );

  for ( nr = 0; nr < MAX_SIGNO; nr++ ) {
    switch( nr )
      {
#ifdef SIGHUP
      case SIGHUP: break;
#endif
#ifdef SIGINT
      case SIGINT: continue; /* GJP 21-02-2004 Handled by handle_interrupt() */
#endif
#ifdef SIGQUIT
      case SIGQUIT: break;
#endif
#ifdef SIGILL
      case SIGILL: break;
#endif
#ifdef SIGTRAP
      case SIGTRAP: break;
#endif
#ifdef SIGABRT
      case SIGABRT: break;
#endif
#ifdef SIGEMT
      case SIGEMT: break;
#endif
#ifdef SIGFPE
      case SIGFPE: break;
#endif
#ifdef SIGBUS
      case SIGBUS: break;
#endif
#ifdef SIGSEGV
      case SIGSEGV: break;
#endif
#ifdef SIGSYS
      case SIGSYS: break;
#endif
#ifdef SIGPIPE
      case SIGPIPE: break;
#endif
#ifdef SIGALRM
      case SIGALRM: break;
#endif
#ifdef SIGTERM
      case SIGTERM: break;
#endif
#ifdef SIGURG
      case SIGURG: break;
#endif
#ifdef SIGSTOP
      case SIGSTOP: break;
#endif
#ifdef SIGTSTP
      case SIGTSTP: break;
#endif
#ifdef SIGCONT
      case SIGCONT: break;
#endif
#ifdef SIGCHLD
      case SIGCHLD: break;
#endif
#ifdef SIGTTIN
      case SIGTTIN: break;
#endif
#ifdef SIGTTOU
      case SIGTTOU: break;
#endif
#ifdef SIGIO
      case SIGIO: break;
#endif
#ifdef SIGXCPU
      case SIGXCPU: break;
#endif
#ifdef SIGXFSZ
      case SIGXFSZ: break;
#endif
#ifdef SIGVTALRM
      case SIGVTALRM: break;
#endif
#ifdef SIGPROF
      case SIGPROF: break;
#endif
#ifdef SIGWINCH
      case SIGWINCH: break;
#endif
#ifdef SIGLOST
      case SIGLOST: break;
#endif
#ifdef SIGUSR1
      case SIGUSR1: break;
#endif
#ifdef SIGUSR2
      case SIGUSR2: break;
#endif
#ifdef SIGBREAK
      case SIGBREAK: break;
#endif
      default:
        continue; /* not a known signal */
      }

    DBUG_PRINT( "info", ( "handler for signal %d (%s): %p", 
                          nr,
                          signal_str(nr),
                          (void*) signal_handler_info[idx][nr].func ) );

    /* store old handler */
    signal_handler_info[idx][nr].func = signal( nr, signal_handler_info[idx][nr].func );
  }

  DBUG_LEAVE();
}

static
void
reset_signal_handlers( const int idx )
{
  set_signal_handlers( idx );
}

/*
** User interrupt handler template.
*/
static
void
handle_interrupt(epc_info_t *epc_info)
{
  DBUG_ENTER( "handle_interrupt" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  /* Use the interrupt context */
  EXEC SQL CONTEXT USE :interrupt_context;

  DBUG_PRINT( "info", ( "context switched" ) );

  EXEC SQL EXECUTE
  BEGIN
    epc_srvr.send_request_interrupt( epc_srvr.get_epc_key );
  END;
  END-EXEC;

  DBUG_PRINT( "info", ( "sqlca.sqlcode: %ld", (long)sqlca.sqlcode ) );

  DBUG_LEAVE();
}

static
void
handle_signal( int signo )
{
  set_signal_handlers( 1 );

  (void) fprintf( stderr, "Received signal %d\n", signo );

  handle_interrupt(interrupt_epc_info);

  G_signo = signo;

  reset_signal_handlers( 1 );
}

/*
  GJP 23-02-2004
  Use the global sqlca structure for handle_interrupt() and 
  epc_info->sqlca for other routines.
*/

#define sqlca (*(epc_info->sqlca))

static
void
print_call ( epc_call_t * call )
/* ----------------------------------------------------------------------
 * Prints out all fields of a call in readable format
 * ----------------------------------------------------------------------*/
{
  DBUG_ENTER( "print_call" );
  DBUG_PRINT( "input", ( "msg info: '%s'", call->msg_info) );
  DBUG_PRINT( "input", 
              ( "interface: '%s'; function: '%s'", 
                (call != NULL && call->interface != NULL && call->interface->name != NULL 
                 ? call->interface->name
                 : "(null)"), 
                (call != NULL && call->function != NULL && call->function->name != NULL
                 ? call->function->name 
                 : "(null)") ) );
  DBUG_PRINT( "input", ( "status: %ld; SQL code: %ld", (long)call->epc_error, (long)call->sqlcode) );
  DBUG_LEAVE();
}

static
epc_error_t
receive_request( epc_info_t *epc_info, epc_call_t *call )
     /* ----------------------------------------------------------------------
      * Receives a clients' request from the specified database pipe
      *
      * return values:
      *              MSG_TIMED_OUT
      *              MSG_TOO_BIG
      *              MSG_INTERRUPTED
      *              RECEIVE_ERROR
      *              DATATYPE_UNKNOWN
      *              OK
      *              any return value from
      *              -       set_function
      *              -       get_parameters
      * ----------------------------------------------------------------------*/
{
  dword_t handle;
  EXEC SQL BEGIN DECLARE SECTION;
  long retval = OK;
  varchar msg_info[MAX_MSG_INFO_LEN] = { 0, "" };     /* client-specific pipe for results  */
  short msg_info_nl; /* null indicator */
  varchar msg_request[MAX_STR_VAL_LEN] = { 0, "" };
  short msg_request_nl; /* null indicator */
  const int msg_timed_out = MSG_TIMED_OUT;
  const int msg_too_big = MSG_TOO_BIG;
  const int msg_interrupted = MSG_INTERRUPTED;
  const int receive_error = RECEIVE_ERROR;
  EXEC SQL END DECLARE SECTION;
  struct xmlctx *xmlctx = NULL;
  epc_xml_ctx_t epc_xml_ctx = { epc_info, call, 0 };

  DBUG_ENTER( "receive_request" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  sqlca.sqlcode = 0;
  call->sqlcode = 0;

  /* All exceptions should be handled within the PL/SQL block hence 
     this default. */
  EXEC SQL WHENEVER SQLERROR DO epc_abort("-- Oracle error --");

  EXEC SQL CONTEXT USE DEFAULT;

  /* set up my user interrupt handler */
  (void) osnsui(&handle, handle_interrupt, epc_info);

  EXEC SQL EXECUTE
  declare
  begin
    epc_srvr.recv_request(epc_srvr.get_epc_key, :msg_request:msg_request_nl, :msg_info:msg_info_nl);
  exception
    when epc.e_msg_timed_out
    then
      :retval := :msg_timed_out;
    when epc.e_msg_too_big
    then
      :retval := :msg_too_big;
    when epc.e_msg_interrupted
    then
      :retval := :msg_interrupted;
    when others
    then
      :retval := :receive_error;
  end;
  END-EXEC;

  (void) osncui(handle);

  DBUG_PRINT( "info", ( "retval: %ld", retval ) );

  if ( retval == OK )
    {
      if ( msg_request_nl == -1 )
        msg_request.len = 0;

      assert(msg_request.len < sizeof(msg_request.arr)); /* arr including terminating zero */

      msg_request.arr[msg_request.len] = '\0';

      if ( msg_info_nl == -1 )
        msg_info.len = 0;

      assert(msg_info.len < sizeof(msg_info.arr)); /* arr including terminating zero */

      msg_info.arr[msg_info.len] = '\0';

      DBUG_PRINT( "info", ( "msg_info: %s", (char*)msg_info.arr ) );

      epc_xml_init( &xmlctx, &epc_xml_ctx );
      epc_xml_parse( xmlctx, (const char*)msg_request.arr, msg_request.len );
      epc_xml_done( &xmlctx );

      (void) strncpy( call->msg_info, (char*)msg_info.arr, sizeof(call->msg_info) );
      call->msg_info[sizeof(call->msg_info)-1] = 0;

#ifndef DBUG_OFF
      print_call( call );
#endif
    }

  call->epc_error = retval;
  DBUG_PRINT( "output", 
              ( "retval: %ld; sql code: %ld; epc error: %ld", 
                retval, (long)call->sqlcode, (long)call->epc_error));

  DBUG_LEAVE(); 
  return retval;
}

static
char *
get_error_str( epc_error_t err )
{
  switch( err ) 
    {
    case OK:
      return "OK";
    case MSG_TIMED_OUT:
      return "MSG_TIMED_OUT";
    case MSG_TOO_BIG:
      return "MSG_TOO_BIG";
    case MSG_INTERRUPTED:
      return "MSG_INTERRUPTED";
    case RECEIVE_ERROR:
      return "RECEIVE_ERROR";
    case EXEC_ERROR:
      return "EXEC_ERROR";
    case MEMORY_ERROR:
      return "MEMORY_ERROR";
    case DATATYPE_UNKNOWN:
      return "DATATYPE_UNKNOWN";
    case FUNCTION_UNKNOWN:
      return "FUNCTION_UNKNOWN";
    case PARAMETER_UNKNOWN:
      return "PARAMETER_UNKNOWN";
    case INTERFACE_UNKNOWN:
      return "INTERFACE_UNKNOWN";
    case PARAMETER_MODE_UNKNOWN:
      return "PARAMETER_MODE_UNKNOWN";
    case SEND_ERROR:
      return "SEND_ERROR";
    case CONNECT_ERROR:
      return "CONNECT_ERROR";
    case DISCONNECT_ERROR:
      return "DISCONNECT_ERROR";
    default:
      return "Unknown error";
    }
}

static
int
epc_cmp_function( const void *par1, const void *par2 )
{
  epc_function_t *fnc1 = (epc_function_t *) par1;
  epc_function_t *fnc2 = (epc_function_t *) par2;

  return strcmp( fnc1->name, fnc2->name );
}

static
int
epc_cmp_interface( const void *par1, const void *par2 )
{
  epc_interface_t *ifc1 = *((epc_interface_t **) par1);
  epc_interface_t *ifc2 = *((epc_interface_t **) par2);

  return strcmp( ifc1->name, ifc2->name );
}

static
epc_error_t
epc_exec_call( epc_info_t * epc_info, epc_call_t * epc_call )
{
  DBUG_ENTER( "epc_exec_call" );

  epc_call->epc_error = OK;

  if ( epc_call->function != NULL )
    {
      EXEC SQL BEGIN DECLARE SECTION;
      char *msg_info = epc_call->msg_info;
      varchar msg_response[MAX_STR_VAL_LEN] = { 0, "" };
      EXEC SQL END DECLARE SECTION;
      dword_t nr;

      (*epc_call->function->function) ( epc_call->function );

      sqlca.sqlcode = 0;
      epc_call->sqlcode = 0;

      (void) snprintf((char*)msg_response.arr, 
                      sizeof(msg_response.arr), 
                      "<?xml version='1.0' encoding='UTF-8'?>\
<SOAP-ENV:Envelope xmlns:SOAP-ENV='http://schemas.xmlsoap.org/soap/envelope/' \
xmlns:SOAP-ENC='http://schemas.xmlsoap.org/soap/encoding/' \
xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \
xmlns:xsd='http://www.w3.org/2001/XMLSchema'>\
<SOAP-ENV:Body><%sResponse xmlns='%s'>", epc_call->function->name, epc_call->interface->name);

      for ( nr = 0; nr < epc_call->function->num_parameters; nr++ )
        {
          if ( epc_call->function->parameters[nr].mode != C_IN )
            {
              (void) snprintf((char*)msg_response.arr, 
                              sizeof(msg_response.arr), 
                              "%s<%s>", 
                              (char*)msg_response.arr, 
                              epc_call->function->parameters[nr].name);

              switch(epc_call->function->parameters[nr].type)
                {
                case C_STRING:
                  (void) snprintf((char*)msg_response.arr, 
                                  sizeof(msg_response.arr), 
                                  "%s%s", 
                                  (char*)msg_response.arr, 
                                  (char*)epc_call->function->parameters[nr].data);
                  break;
      
                case C_INT:
                  (void) snprintf((char*)msg_response.arr, 
                                  sizeof(msg_response.arr), 
                                  "%s%d", 
                                  (char*)msg_response.arr, 
                                  *((int*)epc_call->function->parameters[nr].data));
                  break;

                case C_LONG:
                  (void) snprintf((char*)msg_response.arr, 
                                  sizeof(msg_response.arr), 
                                  "%s%ld", 
                                  (char*)msg_response.arr, 
                                  *((long*)epc_call->function->parameters[nr].data));
                  break;

                case C_FLOAT:
                  (void) snprintf((char*)msg_response.arr, 
                                  sizeof(msg_response.arr), 
                                  "%s%f",
                                  (char*)msg_response.arr, 
                                  (double)(*((float*)epc_call->function->parameters[nr].data)));
                  break;
                  
                case C_DOUBLE:
                  (void) snprintf((char*)msg_response.arr, 
                                  sizeof(msg_response.arr), 
                                  "%s%f", 
                                  (char*)msg_response.arr, 
                                  *((double*)epc_call->function->parameters[nr].data));
                  break;
                          
                case C_VOID: /* impossible */
                  assert( epc_call->function->parameters[nr].type != C_VOID );
                  break;

                default: 
                  assert( epc_call->function->parameters[nr].type >= C_DATATYPE_MIN &&
                          epc_call->function->parameters[nr].type <= C_DATATYPE_MAX );

                }

              (void) snprintf((char*)msg_response.arr, sizeof(msg_response.arr), "%s</%s>", 
                              (char*)msg_response.arr, epc_call->function->parameters[nr].name);
            }
        }

      (void) snprintf((char*)msg_response.arr, sizeof(msg_response.arr), 
                      "%s</%sResponse></SOAP-ENV:Body></SOAP-ENV:Envelope>", 
                      (char*)msg_response.arr, epc_call->function->name);

      msg_response.len = strlen((char*)msg_response.arr);

      DBUG_PRINT( "info", ( "msg_response: %s", (char*)msg_response.arr ) );

      EXEC SQL WHENEVER SQLERROR DO epc_abort("-- Oracle error --");

      EXEC SQL CONTEXT USE DEFAULT;

      EXEC SQL EXECUTE
      declare
      begin
        epc_srvr.send_response
        ( p_epc_key => epc_srvr.get_epc_key
        , p_msg_response => :msg_response
        , p_msg_info => :msg_info
        );
      end;
      END-EXEC;
    }

  DBUG_PRINT( "output", 
              ( "sql code: %ld; epc error: %ld", 
                (long)epc_call->sqlcode, (long)epc_call->epc_error ) );

  DBUG_LEAVE();

  return epc_call->epc_error;
}

/* =====================================================================
 *
 * EXPORTED FUNCTIONS
 *
 *======================================================================*/

long
epc_handle_request( epc_info_t *epc_info, epc_call_t *call )
     /* ----------------------------------------------------------------------
      * Handles a single request received over the specified database pipe:
      * - receives a request message
      * - unpacks the specifications of the requested call
      * - executes the call
      * - packs status and results of the call
      * - sends back the results
      * ----------------------------------------------------------------------*/
{
  EXEC SQL BEGIN DECLARE SECTION;
  char * request_pipe = epc_info->pipe;
  short request_pipe_nl = ( request_pipe == NULL ? -1 : 0 );
  EXEC SQL END DECLARE SECTION;
  long retval = -1L;

  DBUG_ENTER( "epc_handle_request" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  if ( epc_info->first_time != 0 ) 
    {
      int nr;

      EXEC SQL WHENEVER SQLERROR DO epc_abort("-- Oracle error --");

      for ( nr = 0; nr < 2; nr++ )
        {
          switch(nr)
            {
            case 0:
              EXEC SQL CONTEXT USE :interrupt_context;
              break;
            case 1:
              EXEC SQL CONTEXT USE DEFAULT;
              break;
            }

          EXEC SQL EXECUTE
          declare
            l_pipe_name epc.pipe_name_subtype;
            l_epc_key epc_srvr.epc_key_subtype;
          begin
            l_epc_key := epc_srvr.register;
            if ( :request_pipe:request_pipe_nl is not null )
            then
              epc_srvr.set_connection_info( epc_srvr.get_epc_key, :request_pipe:request_pipe_nl );
            end if;
            epc_srvr.get_connection_info( epc_srvr.get_epc_key, l_pipe_name );
            dbms_pipe.purge( l_pipe_name );
          end;
          END-EXEC;
        }

      epc_info->first_time = 0;
    }

  do
    {
      /* receive the request */
      receive_request( epc_info, call );

      if ( !( call->epc_error == FUNCTION_UNKNOWN ||
              call->epc_error == INTERFACE_UNKNOWN ||
              call->epc_error == OK ) )
        break;

      /* do the call */
      epc_exec_call( epc_info, call );

      if ( call->epc_error != OK )
        break;

      retval = 0;
    }
  while (0); /* loop is used only to be able to break out earlier */

  switch( call->epc_error )
    {
    case MSG_TIMED_OUT:
    case RECEIVE_ERROR:
    case SEND_ERROR:
    case OK:
      switch( call->sqlcode )
        {
        case -6556:
        case -6558:
        case -6559: /* dbms_pipe errors */
        case 0:
          retval = 0;
          break;

        default:
          break;
        }
      break;

    default:
      break;
    }

  DBUG_PRINT( "output", 
              ( "retval: %ld; sql code: %ld; epc status: %s", 
                retval, (long)call->sqlcode, get_error_str( call->epc_error ) ) );
  DBUG_LEAVE();

  return retval;
}

epc_error_t
epc_handle_requests( epc_info_t *epc_info )
     /* ----------------------------------------------------------------------
      * Handles all requests received over the specified database pipe:
      * - receives a request message
      * - unpacks the specifications of the requested call
      * - executes the call
      * - packs status and results of the call
      * - sends back the results
      * ----------------------------------------------------------------------*/
{
  epc_call_t call = CALL_INIT;

  DBUG_ENTER( "epc_handle_requests" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  for ( call.sqlcode = 0; G_signo == 0; call.sqlcode = 0 )
    {    
      if ( epc_handle_request( epc_info, &call ) != 0 )
        break;
    }

  if ( G_signo != 0 ) 
    {
      (void) printf( "Signal %d received\n", G_signo );
    }

  DBUG_PRINT( "output", 
              ( "sql code: %ld; epc status: %s", 
                (long)call.sqlcode, get_error_str( call.epc_error ) ) );

  DBUG_LEAVE();

  return call.epc_error;
}

epc_error_t
epc_set_logon( epc_info_t *epc_info, char *logon )
{
  epc_error_t status = OK;

  DBUG_ENTER( "epc_set_logon" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  if ( epc_info == NULL )
    {
      status = MEMORY_ERROR;
    }
  else if ( logon == NULL )
    {
      if ( epc_info->logon != NULL )
        free( epc_info->logon );

      epc_info->logon = NULL;
    }
  else
    {
      epc_info->logon = (char*) realloc( epc_info->logon, strlen(logon) + 1 );
      if ( epc_info->logon == NULL )
        status = MEMORY_ERROR;
      else
        strcpy( epc_info->logon, logon );
    }

  DBUG_PRINT( "output", ( "status: %d", (int)status ) );

  DBUG_LEAVE();

  return( status );
}

epc_error_t
epc_set_pipe( epc_info_t *epc_info, char *pipe )
{
  epc_error_t status = OK;

  DBUG_ENTER( "epc_set_pipe" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  if ( epc_info == NULL )
    {
      status = MEMORY_ERROR;
    }
  else if ( pipe == NULL )
    {
      if ( epc_info->pipe != NULL )
        free( epc_info->pipe );

      epc_info->pipe = NULL;
    }
  else
    {
      epc_info->pipe = (char*) realloc( epc_info->pipe, strlen(pipe) + 1 );
      if ( epc_info->pipe == NULL )
        status = MEMORY_ERROR;
      else
        strcpy( epc_info->pipe, pipe );
    }

  DBUG_PRINT( "output", ( "status: %d", (int)status ) );

  DBUG_LEAVE();
  return( status );
}

epc_error_t
epc_add_interface( epc_info_t *epc_info, epc_interface_t *interface )
{
  epc_error_t status = OK;

  DBUG_ENTER( "epc_add_interface" );
  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  if ( epc_info == NULL )
    {
      status = MEMORY_ERROR;
    }
  else
    {
      epc_info->num_interfaces++;
      epc_info->interfaces = 
        (epc_interface_t**)
        realloc(
                (void*)epc_info->interfaces,
                (size_t)(epc_info->num_interfaces * sizeof(epc_interface_t**))
                );

      if ( epc_info->interfaces == NULL )
        {
          epc_info->num_interfaces--;
          status = MEMORY_ERROR;
        }
      else
        {
          int fnr, pnr;

          epc_info->interfaces[epc_info->num_interfaces - 1] = interface;

          /* sort the functions */
          qsort( interface->functions,
                 interface->num_functions,
                 sizeof(interface->functions[0]),
                 epc_cmp_function );

          /* sort the interfaces */
          qsort( epc_info->interfaces,
                 epc_info->num_interfaces,
                 sizeof(epc_info->interfaces[0]),
                 epc_cmp_interface );

          /* allocate memory for the parameters */
          for ( fnr = 0; fnr < interface->num_functions; fnr++ )
            for ( pnr = 0; pnr < interface->functions[fnr].num_parameters; pnr++ )
              {
                size_t size = 0;

                switch(interface->functions[fnr].parameters[pnr].type)
                  {
                  case C_STRING:
                    size = interface->functions[fnr].parameters[pnr].size + 1;
                    break;
      
                  case C_INT:
                    size = sizeof(int);
                    break;

                  case C_LONG:
                    size = sizeof(long);
                    break;

                  case C_FLOAT:
                    size = sizeof(float);
                    break;
                  
                  case C_DOUBLE:
                    size = sizeof(double);
                    break;
                  
                  case C_VOID: /* impossible */
                    assert( interface->functions[fnr].parameters[pnr].type != C_VOID );
                    break;

                  default: 
                    assert( interface->functions[fnr].parameters[pnr].type >= C_DATATYPE_MIN &&
                            interface->functions[fnr].parameters[pnr].type <= C_DATATYPE_MAX );
                  }
                if ( (interface->functions[fnr].parameters[pnr].data = malloc(size)) == NULL )
                  {
                    status = MEMORY_ERROR;
                    break;
                  }
              }
        }
    }

  DBUG_PRINT( "output", ( "status: %d", (int)status ) );
  DBUG_LEAVE();

  return( status );
}

void
epc_abort( char *msg )
{
  char err_msg[512];
  size_t buf_len, msg_len;

  (void) printf("\n%s\n", msg);
  buf_len = sizeof (err_msg);
  sqlglm(err_msg, &buf_len, &msg_len);
  (void) printf("%.*s\n", msg_len, err_msg);

  exit(EXIT_FAILURE);
}

epc_error_t
epc_connect( epc_info_t *epc_info )
{
  EXEC SQL BEGIN DECLARE SECTION;
  char *logon = epc_info->logon;
  EXEC SQL END DECLARE SECTION;
  epc_error_t status = OK;

  DBUG_ENTER( "epc_connect" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  if ( logon == NULL ) {
    printf( "ERROR: No connect string specified.\n" );
    status = CONNECT_ERROR;
  } else {

    /* log on to database */
    EXEC SQL WHENEVER SQLERROR DO epc_abort("-- Oracle error --");

    EXEC SQL CONTEXT USE DEFAULT;

    EXEC SQL CONNECT :logon;

    EXEC SQL CONTEXT ALLOCATE :interrupt_context;

    EXEC SQL CONTEXT USE :interrupt_context;

    EXEC SQL CONNECT :logon;

    interrupt_epc_info = epc_info;

    printf( "Connected to database....\n" );
    epc_info->connected = TRUE;

    set_signal_handlers( 0 );

    fflush( stdout ); /* flush because of DBUG package */
  }

  DBUG_LEAVE();

  return status;
}

epc_error_t
epc_disconnect( epc_info_t *epc_info )
{
  epc_error_t status = OK;

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  DBUG_ENTER( "epc_disconnect" );

  DBUG_PRINT( "input", ( "epc_info: %p", (void*)epc_info ) );

  reset_signal_handlers( 0 );

  if ( epc_info->connected == TRUE ) {

    (void) printf( "Disconnecting from database....\n" );

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    switch ( G_signo )
      {
      case 0:
        EXEC SQL CONTEXT USE :interrupt_context;

        EXEC SQL COMMIT WORK RELEASE;

        EXEC SQL CONTEXT USE DEFAULT;

        EXEC SQL COMMIT WORK RELEASE;
        break;

      default:
        EXEC SQL CONTEXT USE :interrupt_context;

        EXEC SQL ROLLBACK RELEASE;

        EXEC SQL CONTEXT USE DEFAULT;

        EXEC SQL ROLLBACK RELEASE;
      }

    EXEC SQL CONTEXT FREE :interrupt_context;

    if ( sqlca.sqlcode != 0 ) {
      status = DISCONNECT_ERROR;
    }

    (void) printf( "Disconnected from database....\n" );

  }

  DBUG_LEAVE();

  return status;
}


#undef sqlca

epc_info_t *
epc_init( void )
{
  epc_info_t *epc_info = NULL;

  DBUG_ENTER( "epc_init" );

  epc_info = (epc_info_t*)malloc( sizeof(epc_info_t) );

  DBUG_PRINT( "info", ( "epc_info: %p", (void*)epc_info ) );

  if ( epc_info != NULL )
    {
      epc_info->logon = NULL;
      epc_info->connected = FALSE;
      epc_info->pipe = NULL;
      epc_info->first_time = 1;
      epc_info->num_interfaces = 0;
      epc_info->interfaces = NULL;
      epc_info->sqlca = (struct sqlca *)malloc( sizeof(*(epc_info->sqlca)) );

      assert( sizeof(*(epc_info->sqlca)) == sizeof(struct sqlca) );

      /* initialize */
      *(epc_info->sqlca) = sqlca;
    }

  DBUG_LEAVE();
  return epc_info;
}

void
epc_done( epc_info_t **epc_info )
{
  DBUG_ENTER( "epc_done" );

  DBUG_PRINT( "input", ( "*epc_info: %p", (void*)*epc_info ) );

  if ( *epc_info != NULL )
    {
      if ( (*epc_info)->sqlca != NULL )
        free( (*epc_info)->sqlca );

      if ( (*epc_info)->interfaces != NULL )
        {
          int inr, fnr, pnr;

          for (inr = 0; inr < (*epc_info)->num_interfaces; inr++)
            {
              epc_interface_t *interface = (*epc_info)->interfaces[inr];

              /* free memory for the parameters */
              for ( fnr = 0; fnr < interface->num_functions; fnr++ )
                for ( pnr = 0; pnr < interface->functions[fnr].num_parameters; pnr++ )
                  {
                    size_t size = 0;

                    free( interface->functions[fnr].parameters[pnr].data );
                  }
            }
          
          free( (*epc_info)->interfaces );
        }

      if ( (*epc_info)->pipe != NULL )
        free( (*epc_info)->pipe );

      free( *epc_info );
      *epc_info = NULL;
    }

  DBUG_LEAVE();
}

