/* -*-mode: c-*- */
/*
 * Filename             : $RCSfile$
 *
 * Creation date  : 25-AUG-1997
 *
 * Created by           : Huub van der Wouden
 *
 * Company              : Transfer Solutions bv
 *
 * --- Description -------------------------------------------------------
 * EPC functionality that requires interaction with the Oracle database.
 *
 * --- Revision History --------------------------------------------------
 * $Log$
 * Revision 1.48  2004/10/21 10:37:07  gpaulissen
 * * make lint
 * * error reporting enhanced
 * * oneway functions enhanced
 *
 * Revision 1.47  2004/10/20 20:38:44  gpaulissen
 * make lint
 *
 * Revision 1.46  2004/10/19 19:45:28  gpaulissen
 * CTRL-C behaviour enhanced
 *
 * Revision 1.45  2004/10/19 14:35:08  gpaulissen
 * epc_ -> epc__
 *
 * Revision 1.44  2004/10/18 15:17:33  gpaulissen
 * XML enabling of EPC
 *
 * Revision 1.43  2004/10/15 20:41:32  gpaulissen
 * XML namespace bugs solved.
 *
 * Revision 1.42  2004/10/15 13:53:40  gpaulissen
 * XML added
 *
 * Revision 1.41  2004/05/21 15:07:51  gpaulissen
 * SOAP messages
 *
 * Revision 1.40  2004/03/29 07:23:26  gpaulissen
 * Only call epc.request_get_body when there is input
 *
 * Revision 1.39  2004/03/28 19:04:18  gpaulissen
 * null indicator toegevoegd voor output host arrays
 *
 * Revision 1.38  2004/03/28 15:32:25  gpaulissen
 * Generate C code only.
 *
 * Revision 1.37  2004/03/12 16:30:17  gpaulissen
 * 915081       The EPC idl compiler fails during build of the demo
 * 901781       CTRL-C kills EPC listener but not the session
 * 891761       -v option crashes
 * 699638       Empty connect string dumps core
 *
 * Revision 1.36  2004/03/07 10:43:06  gpaulissen
 * oneway bug with parameters solved
 *
 * Revision 1.35  2004/02/23 15:59:28  gpaulissen
 * sqlca is a member of epc__info structure
 *
 * Revision 1.34  2004/02/22 17:16:20  gpaulissen
 * interrupt_get_request_header added
 *
 * Revision 1.33  2003/08/19 15:55:57  gpaulissen
 * - enhanced searching for sqlplus
 * - enhanced signal handling
 * - make idl_y.h before idl_l.c
 *
 * Revision 1.32  2003/06/08 16:28:20  gpaulissen
 * GNU build system for ts_dbug
 *
 * Revision 1.31  2003/04/10 19:50:26  gpaulissen
 * Update
 *
 * Revision 1.30  2003/03/29 18:31:42  gpaulissen
 * Various fixes
 *
 * Revision 1.29  2003/03/26 21:47:06  gpaulissen
 * Building the epc
 *
 * Revision 1.28  2002/12/01 20:05:30  gpaulissen
 * Autoconf modifications
 *
 * Revision 1.27  2002/10/31 22:21:20  gpaulissen
 * Release 3.0.0a
 *
 * Revision 1.26  2002/01/17 11:46:53  gpaulissen
 * - Call to epc package updated due to changes.
 *
 * Revision 1.25  2001/01/24 16:29:08  gpaulissen
 * Release 2.0.0
 *
 * Revision 1.24  2000/08/14 13:47:39  gpaulissen
 * * Added -v command line option for version info.
 * * Updated build support.
 *
 * Revision 1.23  2000/07/07 12:14:55  gpaulissen
 * Release 1.6.3
 *
 * Revision 1.22  2000/01/13 16:23:24  gpaulissen
 * Version 1.6.0
 *
 * Revision 1.19  1999/11/25 09:15:17  gpaulissen
 * Release 1.5
 *
 * Revision 1.18  1999/11/23 16:05:30  gpaulissen
 * DBUG interface changed.
 *
 * Revision 1.17  1999/10/20 10:55:20  gpaulissen
 * Clean up return pipe when send fails.
 *
 * Revision 1.16  1999/08/26 12:34:54  gpaulissen
 * Added DBUG info
 *
 * Revision 1.15  1998/11/27 14:04:01  gjp
 * Added debugging.
 *
 * Revision 1.14  1998/08/19 06:35:49  gjp
 * Added epc_handle_request.
 *
 * Revision 1.13  1998/08/11 21:03:23  gjp
 * Modified comments.
 *
 * Revision 1.12  1998/07/31 16:23:04  gert-jan
 * Various changes.
 *
 # Revision 1.11  1998/07/27  15:18:54  gert-jan
 # First release.
 #
 * Revision 1.10  1998/05/26 11:06:13  gpauliss
 * Replaced RCS keyword Source by RCSfile
 *
 * Revision 1.9  1998/05/19 19:31:46  gpauliss
 * Used ANSI C syntax for EPC_handle_requests
 *
 * Revision 1.8  1998/05/06 20:20:12  gpauliss
 * Added support for longs
 *
 * Revision 1.7  1998/02/19 17:10:02  gpauliss
 * <>
 *
 * Revision 1.6  1998/02/19 17:05:22  gpauliss
 * Test
 *
 * Revision 1.5  1998/02/19 16:41:06  gpauliss
 * Using dos filename conventions (8.3)
 *
 * Revision 1.4  1998/02/17 20:26:59  gpauliss
 * Changed EPC interface
 *
 * Revision 1.3  1998/02/03 12:55:56  gpauliss
 * Modified EPC_handle_requests for return type and wrong fprintf.
 *
 * Revision 1.2  1998/02/03 09:59:22  gpauliss
 * - Free up memory when needed
 * - Changed message protocol
 * - Removed global use of sqlca structure
 * - Added full error checking
 *
 * Revision 1.1  1998/01/25 15:18:07  gpauliss
 * Initial revision
 *
 *
 */

#if HAVE_CONFIG_H
#include <config.h>
#endif

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC

/* defined on any system */
#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_ERRNO_H
#include <errno.h>
#endif

#if HAVE_SIGNAL_H
#include <signal.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_ASSERT_H
#include <assert.h>
#endif

/*#include <math.h>*/ /* GJP 25-06-2000
                         math.h gives compilation errors on Oracle 8.1.5 on Linux SuSE 6.3 */
#if HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#if HAVE_TIME_H
#include <time.h>
#endif

#endif

/* include sqlca.h even though it has been included already */
#ifdef SQLCA
#undef SQLCA
#endif

/* declare a structure */
#ifdef SQLCA_NONE 
#undef SQLCA_NONE 
#endif

#ifdef SQLCA_STORAGE_CLASS
#undef SQLCA_STORAGE_CLASS
#endif

/* a static sqlca only */
#define SQLCA_STORAGE_CLASS static

/* force initialisation of the static sqlca struct */
#ifndef SQLCA_INIT
#define SQLCA_INIT
#endif

EXEC SQL INCLUDE sqlca;

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include <dbug.h>
#include <epc.h>
#include <idl_defs.h>
#endif

EXEC SQL BEGIN DECLARE SECTION;

EXEC SQL INCLUDE "epc_defs.h";  /* epc-specific type definitions */

EXEC SQL END DECLARE SECTION;

/* include dmalloc as last one */
#ifdef WITH_DMALLOC
#include "dmalloc.h"
#endif

/* =====================================================================
 *
 * LOCAL DEFINITIONS
 *
 *======================================================================*/

/*
  [ 901781 ] CTRL-C kills EPC listener but not the session

  GJP 21-02-2004
  Both osnsui() and osncui() are hidden functions on Windows.
  However they seem to work exactly the same as on Unix platforms.
*/

#ifdef SERVER_INTERRUPT

/* user side interrupt set */
extern
dword_t
osnsui( dword_t *handlp, void (*astp)(epc__info_t *ctx), epc__info_t *ctx );
/*
** osnsui: Operating System dependent Network Set User-side Interrupt.
**         Add an interrupt handling procedure astp.
**         Whenever a user interrupt(such as a ^C) occurs, call astp
**         with argument ctx. Put in *handlp handle for this
**         handler so that it may be cleared with osncui.
**         Note that there may be many handlers; each should
**         be cleared using osncui. An error code is
**         returned if an error occurs.
*/

/* user side interrupt clear */
extern
dword_t
osncui( dword_t handle );
/*
** osncui: Operating System dependent Clear User-side Interrupt.
**         Clear the specified handler. The argument is the
**         handle obtained from osnsui. An error code is
**         returned if an error occurs.
*/


/*
** User interrupt handler template.
*/
static
void
handle_interrupt(epc__info_t *epc__info)
{
  int status;
  char command[1000+1];

  DBUG_ENTER( "handle_interrupt" );

  DBUG_PRINT( "input", ( "epc__info: %p", (void*)epc__info ) );

  (void) snprintf(command, sizeof(command),
                  "epcdaemon %s -I %s %s -u %s",
                  epc__info->program,
                  (epc__info->pipe != NULL ? "-p" : ""),
                  (epc__info->pipe != NULL ? epc__info->pipe : ""),
                  epc__info->logon);

  DBUG_PRINT( "input", ( "command: %s", command ) );

  status = system(command);

  DBUG_PRINT( "input", ( "status: %d; errno: %d", status, errno ) ); 

  if (status == -1)
    {
      /* fork failed */
      exit(EXIT_FAILURE);
    }

  DBUG_LEAVE();
}

#endif /* #ifdef SERVER_INTERRUPT */

void
epc__abort( char *msg )
{
  char err_msg[512];
  size_t buf_len, msg_len;

  (void) printf("\n%s\n", msg);
  buf_len = sizeof (err_msg);
  sqlglm(err_msg, &buf_len, &msg_len);
  (void) printf("%.*s\n", msg_len, err_msg);

  exit(EXIT_FAILURE);
}


/*
  GJP 23-02-2004
  Use the global sqlca structure for handle_interrupt() and 
  epc__info->sqlca for other routines.
*/

epc__error_t
epc__connect( epc__info_t *epc__info )
{
  EXEC SQL BEGIN DECLARE SECTION;
  char *logon = epc__info->logon;
  char *request_pipe = epc__info->pipe;
  short request_pipe_nl = ( request_pipe == NULL ? -1 : 0 );
  int purge_pipe = epc__info->purge_pipe;
  EXEC SQL END DECLARE SECTION;
  epc__error_t status = OK;

  DBUG_ENTER( "epc__connect" );

  DBUG_PRINT( "input", ( "epc__info: %p", (void*)epc__info ) );

  if ( logon == NULL ) 
    {
      printf( "ERROR: No connect string specified.\n" );
      status = CONNECT_ERROR;
    } 
  else 
    {
      if ( epc__info->sqlca == NULL )
        {
          epc__info->sqlca = (struct sqlca *)malloc( sizeof(*(epc__info->sqlca)) );

          assert( sizeof(*(epc__info->sqlca)) == sizeof(struct sqlca) );

          /* initialize */
          *(epc__info->sqlca) = sqlca;
        }

#define sqlca (*(epc__info->sqlca))

      /* log on to database */
      EXEC SQL WHENEVER SQLERROR DO epc__abort("-- Oracle error --");

      EXEC SQL CONNECT :logon;

      printf( "Connected to database....\n" );
      epc__info->connected = 1;
    
#ifdef SERVER_INTERRUPT
      epc__set_handle_interrupt(handle_interrupt, epc__info);
#endif
      epc__set_signal_handlers( 0 );

      fflush( stdout ); /* flush because of DBUG package */

      EXEC SQL EXECUTE
      declare
        l_pipe_name epc.pipe_name_subtype;
        l_epc_key epc_srvr.epc_key_subtype;
      begin
        /*DBUG*/ dbug.activate('LOG4PLSQL');
        /*DBUG*/ dbug.enter('epc__connect');
        dbms_output.enable(1000000);
        l_epc_key := epc_srvr.register;
        if ( :request_pipe:request_pipe_nl is not null )
        then
          epc_srvr.set_connection_info( epc_srvr.get_epc_key, :request_pipe:request_pipe_nl );
        end if;
        epc_srvr.get_connection_info( epc_srvr.get_epc_key, l_pipe_name );
        if :purge_pipe != 0
        then
          dbms_pipe.purge( l_pipe_name );
        end if;
        /*DBUG*/ dbug.leave;
      end;
      END-EXEC;
    }

  DBUG_LEAVE();

  return status;
}

epc__error_t
epc__interrupt( epc__info_t *epc__info )
{
  epc__error_t status = OK;

  DBUG_ENTER( "epc__interrupt" );

  DBUG_PRINT( "input", ( "epc__info: %p", (void*)epc__info ) );

  EXEC SQL WHENEVER SQLERROR DO epc__abort("-- Oracle error --");

  EXEC SQL EXECUTE
  begin
    /*DBUG*/ dbug.enter('epc__interrupt');
    epc_srvr.send_request_interrupt( epc_srvr.get_epc_key );
    /*DBUG*/ dbug.leave;
  end;
  END-EXEC;

  DBUG_LEAVE();

  return status;
}

epc__error_t
epc__disconnect( epc__info_t *epc__info )
{
  epc__error_t status = OK;

  DBUG_ENTER( "epc__disconnect" );

  DBUG_PRINT( "input", ( "epc__info: %p", (void*)epc__info ) );

  epc__reset_signal_handlers( 0 );

  if ( epc__info->connected != 0 ) {
    EXEC SQL BEGIN DECLARE SECTION;
#define NUMLINES 100
    char line[NUMLINES][255+1];
    short line_nl[NUMLINES];
    short numlines_nl;
    int numlines;
    EXEC SQL VAR line IS STRING(255+1);
    EXEC SQL END DECLARE SECTION;
    int nr;

    (void) printf( "Disconnecting from database....\n" );
    (void) printf( "Showing dbms_output....\n" );

    while (1) {
      numlines = NUMLINES;

      EXEC SQL EXECUTE
      declare
	l_line dbms_output.chararr;
      begin
        dbms_output.get_lines(l_line, :numlines INDICATOR :numlines_nl);
	if l_line.count > 0
	then
  	  for i_nr in l_line.first .. l_line.last
	  loop
            :line INDICATOR :line_nl(1 + (i_nr - l_line.first)) := l_line(i_nr);
          end loop;
	else
          :line(1) := 'N/A';
	end if;
      end;
      END-EXEC;
      
      if (numlines_nl == -1) {
	numlines = 0;
      }

      for (nr = 0; nr < numlines; nr++)
	{
	  size_t length;

	  if (line_nl[nr] == -1) {
	    line[nr][0] = '\0';
	  }

	  /* line[nr] may contain \n and/or \r: skip them */
	  length = strcspn(line[nr], "\n\r");

	  (void) printf( "%.*s\n", (int) length, line[nr] );
	}

      if (numlines < NUMLINES) {
        break;
      }
    }

    /* All exceptions should be handled within the PL/SQL block hence 
       this default. */
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    switch ( epc__get_signo() )
      {
      case 0: /* no signal: OK */
        EXEC SQL COMMIT WORK RELEASE;
        break;

      default:
        EXEC SQL ROLLBACK RELEASE;
        break;
      }

    if ( sqlca.sqlcode != 0 ) {
      status = DISCONNECT_ERROR;
    }

    (void) printf( "Disconnected from database....\n" );

  }

  DBUG_LEAVE();

  return status;
}


epc__error_t
epc__recv_request_pipe( epc__info_t *epc__info, epc__call_t *epc__call )
     /* ----------------------------------------------------------------------
      * Receives a clients' request from the specified database pipe
      *
      * return values:
      *              MSG_TIMED_OUT
      *              MSG_TOO_BIG
      *              MSG_INTERRUPTED
      *              RECEIVE_ERROR
      *              DATATYPE_UNKNOWN
      *              OK
      *              any return value from
      *              -       set_function
      *              -       get_parameters
      * ----------------------------------------------------------------------*/
{
  dword_t handle;
  EXEC SQL BEGIN DECLARE SECTION;
  long retval = OK;
  char *msg_info = epc__call->msg_info;
  /* STRING(n) is s C-like character of size n (including terminating zero) */
  EXEC SQL VAR msg_info IS STRING(MAX_MSG_INFO_LEN+1); /* client-specific pipe for results  */
  short msg_info_nl; /* null indicator */
  char *msg_request = epc__call->msg_request;
  EXEC SQL VAR msg_request IS STRING(MAX_MSG_REQUEST_LEN+1); /* client-specific pipe for results  */
  short msg_request_nl; /* null indicator */
  char interface_name[MAX_INTERFACE_NAME_LEN+1] = "";
  EXEC SQL VAR interface_name IS STRING(MAX_INTERFACE_NAME_LEN+1);
  short interface_name_nl; /* null indicator */
  char function_name[MAX_FUNC_NAME_LEN+1] = "";
  EXEC SQL VAR function_name IS STRING(MAX_FUNC_NAME_LEN+1);
  short function_name_nl; /* null indicator */
  const int msg_timed_out = MSG_TIMED_OUT;
  const int msg_too_big = MSG_TOO_BIG;
  const int msg_interrupted = MSG_INTERRUPTED;
  const int receive_error = RECEIVE_ERROR;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER( "epc__recv_request_pipe" );

  DBUG_PRINT( "input", ( "epc__info: %p", (void*)epc__info ) );

  sqlca.sqlcode = 0;
  epc__call->errcode = 0;
  msg_info[0] = '\0';
  msg_request[0] = '\0';
  epc__call->interface = NULL;
  epc__call->function = NULL;

  EXEC SQL WHENEVER SQLERROR DO epc__abort("-- Oracle error --");

#ifdef SERVER_INTERRUPT
  /* set up my user interrupt handler */
  (void) osnsui(&handle, handle_interrupt, epc__info);
#endif

  EXEC SQL EXECUTE
  declare
  begin
    /*DBUG*/ dbug.enter('epc__recv_request_pipe');
    epc_srvr.recv_request
    ( p_epc_key => epc_srvr.get_epc_key
    , p_msg_info => :msg_info:msg_info_nl
    , p_msg_request => :msg_request:msg_request_nl
    , p_interface_name => :interface_name:interface_name_nl
    , p_function_name => :function_name:function_name_nl
    );
    /*DBUG*/ dbug.leave;
  exception
    when epc.e_msg_timed_out
    then
      :retval := :msg_timed_out;
    when epc.e_msg_too_big
    then
      :retval := :msg_too_big;
    when epc.e_msg_interrupted
    then
      :retval := :msg_interrupted;
    when others
    then
      :retval := :receive_error;
  end;
  END-EXEC;

#ifdef SERVER_INTERRUPT
  (void) osncui(handle);
#endif

  DBUG_PRINT( "info", ( "retval: %ld", retval ) );

  if ( retval == OK )
    {
      /* either msg_request OR interface and function must be set */
      assert( (msg_request_nl == -1 && interface_name_nl != -1 && function_name_nl != -1) ||
              (msg_request_nl != -1 && interface_name_nl == -1 && function_name_nl == -1) );

      if ( msg_request_nl == -1 )
        msg_request[0] = '\0';

      assert(strlen(msg_request) <= MAX_MSG_REQUEST_LEN);

      if ( msg_info_nl == -1 )
        msg_info[0] = '\0';

      assert(strlen(msg_info) <= MAX_MSG_INFO_LEN);

      DBUG_PRINT( "info", ( "msg_info: %s", msg_info ) );

      if ( interface_name_nl == -1 )
        interface_name[0] = '\0';

      assert(strlen(interface_name) <= MAX_INTERFACE_NAME_LEN);
              
      if ( function_name_nl == -1 )
        function_name[0] = '\0';
      
      assert(strlen(function_name) <= MAX_FUNC_NAME_LEN);

      if (msg_request[0] == '\0')
        {
          epc__lookup_interface (interface_name, epc__info, epc__call);
          epc__lookup_function (function_name, epc__info, epc__call);

          switch (epc__call->epc__error)
            {
            case INTERFACE_UNKNOWN:
              break;
              
            case FUNCTION_UNKNOWN:
              break;

            case OK:
              break;

            default:
              assert (epc__call->epc__error == INTERFACE_UNKNOWN
                      || epc__call->epc__error == FUNCTION_UNKNOWN
                      || epc__call->epc__error == OK);
            }
        }
#ifndef DBUG_OFF
      epc__call_print( epc__call );
#endif

    }

  epc__call->epc__error = retval;
  DBUG_PRINT( "output", 
              ( "retval: %ld; error code: %ld; epc error: %ld", 
                retval, (long)epc__call->errcode, (long)epc__call->epc__error));

  DBUG_LEAVE(); 
  return retval;
}

epc__error_t
epc__send_response_pipe( epc__info_t * epc__info, epc__call_t * epc__call )
{
  EXEC SQL BEGIN DECLARE SECTION;
  char *msg_info = epc__call->msg_info;
  EXEC SQL VAR msg_info IS STRING(MAX_MSG_INFO_LEN+1);
  long error_code = epc__call->epc__error;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER( "epc__send_response_pipe" );

  epc__call->epc__error = OK;

  assert(epc__call != NULL);
  assert( epc__call->function == NULL || epc__call->function->oneway == 0 );

  sqlca.sqlcode = 0;
  epc__call->errcode = 0;

  DBUG_PRINT ("info", ("msg_info: %s", msg_info));

  if (msg_info[0] != '\0' && (epc__call->function == NULL || epc__call->function->oneway == 0))
    {
      EXEC SQL WHENEVER SQLERROR DO epc__abort("-- Oracle error --");

      switch (EPC__CALL_PROTOCOL(epc__call))
        {
        case PROTOCOL_NATIVE:
	  /* Only call when error code is set */
	  if (error_code != OK) {
	    EXEC SQL EXECUTE
	    begin
              /*DBUG*/ dbug.enter('epc__send_response_pipe (1)');
              epc_srvr.send_response
              ( p_epc_key => epc_srvr.get_epc_key
              , p_msg_info => :msg_info
  	      , p_error_code => :error_code
              );
              /*DBUG*/ dbug.leave;
            end;
            END-EXEC;
	  }
          break;

        case PROTOCOL_SOAP:
        case PROTOCOL_XMLRPC:
          {
            EXEC SQL BEGIN DECLARE SECTION;
            char *msg_response = epc__call->msg_response;
            EXEC SQL VAR msg_response IS STRING(MAX_MSG_RESPONSE_LEN+1);
            EXEC SQL END DECLARE SECTION;

            DBUG_PRINT ("info", ("msg_response: %s", msg_response));

            EXEC SQL EXECUTE
            begin
              /*DBUG*/ dbug.enter('epc__send_response_pipe (2)');
              epc_srvr.send_response
              ( p_epc_key => epc_srvr.get_epc_key
              , p_msg_response => :msg_response
              , p_msg_info => :msg_info
              );
              /*DBUG*/ dbug.leave;
            end;
            END-EXEC;
          }
          break;

        default:
          assert(EPC__CALL_PROTOCOL(epc__call) >= PROTOCOL_XML_MIN ||
                 EPC__CALL_PROTOCOL(epc__call) <= PROTOCOL_XML_MAX);
          break;
        }
      DBUG_PRINT( "output", 
                  ( "error code: %ld; epc error: %ld", 
                    (long)epc__call->errcode, (long)epc__call->epc__error ) );

    }

  DBUG_LEAVE();

  return epc__call->epc__error;
}

#ifdef sqlca
#undef sqlca
#endif

void
epc__request_native(epc__call_t * epc__call)
{
  dword_t nr;

  DBUG_ENTER ("epc__request_native");

  assert(epc__call != NULL);
  assert(epc__call->interface != NULL);
  assert(epc__call->function != NULL);
  assert(EPC__CALL_PROTOCOL(epc__call) == PROTOCOL_NATIVE);

  DBUG_PRINT ("info", ("method: %s.%s", epc__call->interface->name, epc__call->function->name));

  EXEC SQL WHENEVER SQLERROR DO epc__abort("-- Oracle error --");

  for (nr = 0; nr < epc__call->function->num_parameters; nr++)
    {
      if (epc__call->function->parameters[nr].mode != C_OUT)
        {
          DBUG_PRINT ("info", ("parameter: %s; address: %p; type: %d",
                               epc__call->function->parameters[nr].name,
                               epc__call->function->parameters[nr].data,
                               (int)epc__call->function->parameters[nr].type));

          switch (epc__call->function->parameters[nr].type)
            {
            case C_DATE:
            case C_STRING:
            case C_XML:
              {
                EXEC SQL BEGIN DECLARE SECTION;
                char *l_string = (char *) epc__call->function->parameters[nr].data;
                EXEC SQL VAR l_string IS STRING(MAX_MSG_REQUEST_LEN+1); /* client-specific pipe for results  */
                EXEC SQL END DECLARE SECTION;

                l_string[0] = '\0';
                EXEC SQL EXECUTE
                begin
                  dbms_pipe.unpack_message(:l_string);
                end;
                END-EXEC;
                assert(strlen(l_string) <= epc__call->function->parameters[nr].size);
              }
              break;

            case C_INT:
              {
                EXEC SQL BEGIN DECLARE SECTION;
                int *l_int = (idl_int_t *) epc__call->function->parameters[nr].data;
                EXEC SQL END DECLARE SECTION;

                *l_int = 0;
                EXEC SQL EXECUTE
                begin
                  dbms_pipe.unpack_message(:l_int);
                end;
                END-EXEC;
              }
              break;

            case C_LONG:
              {
                EXEC SQL BEGIN DECLARE SECTION;
                long *l_long = (idl_long_t *) epc__call->function->parameters[nr].data;
                EXEC SQL END DECLARE SECTION;

                *l_long = 0L;
                EXEC SQL EXECUTE
                begin
                  dbms_pipe.unpack_message(:l_long);
                end;
                END-EXEC;
              }
              break;

            case C_FLOAT:
              {
                EXEC SQL BEGIN DECLARE SECTION;
                float *l_float = (idl_float_t *) epc__call->function->parameters[nr].data;
                EXEC SQL END DECLARE SECTION;

                *l_float = 0.0F;
                EXEC SQL EXECUTE
                begin
                  dbms_pipe.unpack_message(:l_float);
                end;
                END-EXEC;
              }
              break;

            case C_DOUBLE:
              {
                EXEC SQL BEGIN DECLARE SECTION;
                double *l_double = (idl_double_t *) epc__call->function->parameters[nr].data;
                EXEC SQL END DECLARE SECTION;

                *l_double = 0.0F;
                EXEC SQL EXECUTE
                begin
                  dbms_pipe.unpack_message(:l_double);
                end;
                END-EXEC;
              }
              break;

            case C_VOID:        /* procedure */
              assert (epc__call->function->parameters[nr].mode == C_OUT);
              break;

            default:
              assert (epc__call->function->parameters[nr].type >= C_DATATYPE_MIN
                      && epc__call->function->parameters[nr].type <= C_DATATYPE_MAX);

            }
        }
    }

  DBUG_LEAVE ();
}


void
epc__response_native(epc__call_t * epc__call)
{
  EXEC SQL BEGIN DECLARE SECTION;
  char *msg_info = epc__call->msg_info;
  EXEC SQL VAR msg_info IS STRING(MAX_MSG_INFO_LEN+1);
  long error_code = epc__call->epc__error;
  EXEC SQL END DECLARE SECTION;
  dword_t nr;

  DBUG_ENTER ("epc__response_native");

  assert(epc__call != NULL);
  assert(epc__call->interface != NULL);
  assert(epc__call->function != NULL);
  assert(epc__call->function->oneway == 0);
  assert(EPC__CALL_PROTOCOL(epc__call) == PROTOCOL_NATIVE);

  DBUG_PRINT ("info", ("method: %s.%s", epc__call->interface->name, epc__call->function->name));

  EXEC SQL WHENEVER SQLERROR DO epc__abort("-- Oracle error --");

  EXEC SQL EXECUTE
  begin
    /*DBUG*/ dbug.enter('epc__response_native');
    epc_srvr.new_response
    ( p_epc_key => epc_srvr.get_epc_key
    , p_msg_info => :msg_info
    );
  end;
  END-EXEC;

  for (nr = 0; nr < epc__call->function->num_parameters; nr++)
    {
      if (epc__call->function->parameters[nr].mode != C_IN)
        {
          /* All input should be not null, hence we do not need indicator variables */
          EXEC SQL BEGIN DECLARE SECTION;
          char *l_string = (char *) epc__call->function->parameters[nr].data;
          EXEC SQL VAR l_string IS STRING(MAX_MSG_REQUEST_LEN+1); /* client-specific pipe for results  */
          int *l_int = (idl_int_t *) epc__call->function->parameters[nr].data;
          long *l_long = (idl_long_t *) epc__call->function->parameters[nr].data;
          float *l_float = (idl_float_t *) epc__call->function->parameters[nr].data;
          double *l_double = (idl_double_t *) epc__call->function->parameters[nr].data;
          EXEC SQL END DECLARE SECTION;

          DBUG_PRINT ("info", ("parameter: %s (%p)",
                               epc__call->function->parameters[nr].name,
                               epc__call->function->parameters[nr].data));

          switch (epc__call->function->parameters[nr].type)
            {
            case C_DATE:
            case C_STRING:
            case C_XML:
              assert(strlen(l_string) <= epc__call->function->parameters[nr].size);
              EXEC SQL EXECUTE
              begin
                dbms_pipe.pack_message(:l_string);
              end;
              END-EXEC;
              break;

            case C_INT:
              EXEC SQL EXECUTE
              begin
                dbms_pipe.pack_message(:l_int);
              end;
              END-EXEC;
              break;

            case C_LONG:
              EXEC SQL EXECUTE
              begin
                dbms_pipe.pack_message(:l_long);
              end;
              END-EXEC;
              break;

            case C_FLOAT:
              EXEC SQL EXECUTE
              begin
                dbms_pipe.pack_message(:l_float);
              end;
              END-EXEC;
              break;

            case C_DOUBLE:
              EXEC SQL EXECUTE
              begin
                dbms_pipe.pack_message(:l_double);
              end;
              END-EXEC;
              break;

            case C_VOID:        /* procedure */
              assert (epc__call->function->parameters[nr].mode == C_OUT);
              break;

            default:
              assert (epc__call->function->parameters[nr].type >= C_DATATYPE_MIN
                      && epc__call->function->parameters[nr].type <= C_DATATYPE_MAX);

            }
        }
    }

  EXEC SQL EXECUTE
  begin
    epc_srvr.send_response
    ( p_epc_key => epc_srvr.get_epc_key
    , p_msg_info => :msg_info
    );
    /*DBUG*/ dbug.leave;
  end;
  END-EXEC;

  DBUG_LEAVE ();
}

/* sqlca is undefined here */
