/*
 * Filename   		: $RCSfile$
 *
 * Creation date  : 25-AUG-1997
 *
 * Created by 		: Huub van der Wouden
 *
 * Company    		: Transfer Solutions bv
 *
 * --- Description -------------------------------------------------------
 * EPC functionality that requires interaction with the Oracle database.
 *
 * --- Revision History --------------------------------------------------
 * $Log$
 * Revision 1.12  1998/07/31 16:23:04  gert-jan
 * Various changes.
 *
# Revision 1.11  1998/07/27  15:18:54  gert-jan
# First release.
#
 * Revision 1.10  1998/05/26 11:06:13  gpauliss
 * Replaced $Source$ by $RCSfile$
 *
 * Revision 1.9  1998/05/19 19:31:46  gpauliss
 * Used ANSI C syntax for EPC_handle_requests
 *
 * Revision 1.8  1998/05/06 20:20:12  gpauliss
 * Added support for longs
 *
 * Revision 1.7  1998/02/19 17:10:02  gpauliss
 * <>
 *
 * Revision 1.6  1998/02/19 17:05:22  gpauliss
 * Test
 *
 * Revision 1.5  1998/02/19 16:41:06  gpauliss
 * Using dos filename conventions (8.3)
 *
 * Revision 1.4  1998/02/17 20:26:59  gpauliss
 * Changed EPC interface
 *
 * Revision 1.3  1998/02/03 12:55:56  gpauliss
 * Modified EPC_handle_requests for return type and wrong fprintf.
 *
 * Revision 1.2  1998/02/03 09:59:22  gpauliss
 * - Free up memory when needed
 * - Changed message protocol
 * - Removed global use of sqlca structure
 * - Added full error checking
 *
 * Revision 1.1  1998/01/25 15:18:07  gpauliss
 * Initial revision
 *
 *
 */
	/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#endif

/* force initialisation of any sqlca struct */
#define SQLCA_INIT

EXEC SQL BEGIN DECLARE SECTION;

EXEC SQL INCLUDE "epc_defs.h";  /* epc-specific type definitions */

EXEC SQL END DECLARE SECTION;

	/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include "epc_call.h"   /* server-side marshalling and call mechanism */
#include "epc_dbg.h"  /* trace and debug functionality */
#include "epc.h"
#endif

/* =====================================================================
 *
 * LOCAL DEFINITIONS
 *
 *======================================================================*/


static
epc_error_t
receive_request( epc_call_t * call )
/* ----------------------------------------------------------------------
 * Receives a clients' request from the specified database pipe
 *
 * return values:
 *		MSG_TIMED_OUT
 *		MSG_TOO_BIG
 *		MSG_INTERRUPTED
 *		RECEIVE_ERROR
 *		DATATYPE_UNKNOWN
 *		OK
 *		any return value from
 *              -       set_function
 *		-	get_parameters
 * ----------------------------------------------------------------------*/
{

		/* declare a volatile struct: thread ready */

#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
   	long retval = OK;
	varchar result_pipe[MAX_PIPE_NAME_LEN] = { 0, "" };     /* client-specific pipe for results  */
	short result_pipe_nl; /* null indicator */
	varchar interface_name[MAX_INTERFACE_NAME_LEN] = { 0, "" };
	short interface_name_nl; /* null indicator */
   	varchar function_name[MAX_FUNC_NAME_LEN] = { 0, "" };
	short function_name_nl; /* null indicator */
	EXEC SQL END DECLARE SECTION;

	epc_debug( "entering receive_request\n" );

	sqlca.sqlcode = 0;
	call->sqlcode = 0;

	EXEC SQL WHENEVER SQLERROR GOTO receive_error;
	EXEC SQL EXECUTE
	BEGIN
     		:retval := 
			epc.request_get_header
			( 
				:result_pipe:result_pipe_nl
			,	:interface_name:interface_name_nl
			,	:function_name:function_name_nl
			);
	END;
	END-EXEC;

	switch( retval )
	{
	case 1: 
		retval = MSG_TIMED_OUT; 
		goto end_of_receive_request;
		break;
	case 2: 
		retval = MSG_TOO_BIG; 
		goto end_of_receive_request;
		break;
	case 3: 
		retval = MSG_INTERRUPTED; 
		goto end_of_receive_request;
		break;
	case 0:
		if ( result_pipe_nl == -1 )
			result_pipe.len = 0;
		result_pipe.arr[result_pipe.len] = '\0';

		if ( interface_name_nl == -1 )
			interface_name.len = 0;
		interface_name.arr[interface_name.len] = '\0';

		if ( function_name_nl == -1 )
			function_name.len = 0;
		function_name.arr[function_name.len] = '\0';

		retval = set_function( 
				  call
				, (char *) result_pipe.arr
				, (char *) interface_name.arr
				, (char *) function_name.arr
				);
		if ( retval != OK )
			goto end_of_receive_request;

		print_call( call );
		goto end_of_receive_request;
		break;

	default:
		/* ?? */
		retval = RECEIVE_ERROR;
		goto end_of_receive_request;
	}

receive_error:
	call->sqlcode = sqlca.sqlcode;
	retval = RECEIVE_ERROR;

end_of_receive_request:
	call->epc_error = retval;
	epc_debug( "receive_request#sql code: %ld\n", (long)call->sqlcode );
	epc_debug( "receive_request#epc error: %ld\n", (long)call->epc_error );
	epc_debug( "leaving receive_request\n" );
	return retval;
}


static
epc_error_t
send_result ( epc_call_t * call )
/* ----------------------------------------------------------------------
 * Packs the result of the call as specified by the call spec and the
 * status of the call, into a message, and sends it through the specified
 * database pipe.
 *
 * return values:
 *		status if not OK
 *		return value of pack_value if not OK
 *		MSG_TIMED_OUT
 *		MSG_INTERRUPTED
 *		OK
 *		SEND_ERROR
 * ----------------------------------------------------------------------*/
{
#define SQLCA_INIT
#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

#define retval call->epc_error

	EXEC SQL BEGIN DECLARE SECTION;
	const char *result_pipe = call->result_pipe;
	EXEC SQL END DECLARE SECTION;

	epc_debug( "entering send_result\n" );
	epc_debug( "sending result through pipe %s\n", result_pipe );

	sqlca.sqlcode = 0;
		
	if ( call->epc_error != OK )
	{
		EXEC SQL BEGIN DECLARE SECTION;
		long epc_error = call->epc_error;
		long sqlcode = call->sqlcode;
		EXEC SQL END DECLARE SECTION;

		EXEC SQL WHENEVER SQLERROR GOTO send_error;
		EXEC SQL EXECUTE
		BEGIN
			dbms_pipe.reset_buffer;
			dbms_pipe.pack_message( :epc_error );
			dbms_pipe.pack_message( :sqlcode );
			:retval := dbms_pipe.send_message( :result_pipe );
		END;
		END-EXEC;
	}
	else
	{
		EXEC SQL WHENEVER SQLERROR GOTO send_error;
		EXEC SQL EXECUTE
		BEGIN
			:retval := dbms_pipe.send_message( :result_pipe );
		END;
		END-EXEC;
	}

	call->sqlcode = 0;

	switch( retval )
	{
	case 1: /* timed out */
		retval = MSG_TIMED_OUT;
		goto end_of_send_result;
	case 3: /* interrupted */;
		retval = MSG_INTERRUPTED;
		goto end_of_send_result;
	case 0: /* OK */
		retval = OK;
		goto end_of_send_result;
	default:
		break; /* goto send_error */
	}

send_error:
	call->sqlcode = sqlca.sqlcode;
	retval = SEND_ERROR;

end_of_send_result:
	epc_debug( "send_result#sql code: %ld\n", (long)call->sqlcode );
	epc_debug( "send_result#retval: %ld\n", (long)retval );
	epc_debug( "leaving send_result\n" );
	return retval;

#ifdef retval
#undef retval
#endif
}


static
char *
get_error_str( epc_error_t err )
{
	switch( err ) {
		case OK:
			return "OK";
		case MSG_TIMED_OUT:
			return "MSG_TIMED_OUT";
		case MSG_TOO_BIG:
			return "MSG_TOO_BIG";
		case MSG_INTERRUPTED:
			return "MSG_INTERRUPTED";
		case RECEIVE_ERROR:
			return "RECEIVE_ERROR";
		case EXEC_ERROR:
			return "EXEC_ERROR";
		case MEMORY_ERROR:
			return "MEMORY_ERROR";
		case DATATYPE_UNKNOWN:
			return "DATATYPE_UNKNOWN";
		case FUNCTION_UNKNOWN:
			return "FUNCTION_UNKNOWN";
		case INTERFACE_UNKNOWN:
			return "INTERFACE_UNKNOWN";
		case PARAMETER_MODE_UNKNOWN:
			return "PARAMETER_MODE_UNKNOWN";
		case SEND_ERROR:
			return "SEND_ERROR";
		default:
			return "Unknown error";
	}
}

/* =====================================================================
 *
 * EXPORTED FUNCTIONS
 *
 *======================================================================*/
 
epc_error_t
epc_handle_requests( epc_info_t *epc_info )
/* ----------------------------------------------------------------------
 * Handles all requests received over the specified database pipe:
 * - receives a request message
 * - unpacks the specifications of the requested call
 * - executes the call
 * - packs status and results of the call
 * - sends back the results
 * ----------------------------------------------------------------------*/
{
#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char * request_pipe = epc_info->pipe;
	char * logon = epc_info->logon;
	EXEC SQL END DECLARE SECTION;
	epc_call_t call = CALL_INIT;

	epc_debug( "entering epc_handle_requests\n" );

	/* log on to database */
	EXEC SQL WHENEVER SQLERROR GOTO end_of_epc_handle_requests;
	EXEC SQL CONNECT :logon;

	printf( "epc listener started - logon %s, pipe %s\n\n", 
		logon, (request_pipe?request_pipe:"(null)") );

	if ( request_pipe != NULL ) {

		EXEC SQL EXECUTE
		BEGIN
				epc.set_request_pipe( :request_pipe );
		END;
		END-EXEC;

	}

	for( call.sqlcode = 0;; call.sqlcode = 0 ) 
	{ 
			/* receive the requests */
		receive_request( &call );

		if ( call.epc_error != OK )
			goto error;

			/* do the call */
		epc_exec_call( &call, epc_info );

		switch ( call.epc_error )
		{
		case FUNCTION_UNKNOWN:
		case INTERFACE_UNKNOWN:
		case OK:
			break;

		default:
			goto error;
		}

			/* send the result */
		send_result( &call ); 

		if ( call.epc_error != OK )
			goto error;

			/* call.epc_error == OK */
		continue;

	error:
		fprintf( stderr, "epc_handle_requests#epc status: %s\n", get_error_str( call.epc_error ) );

		switch( call.epc_error )
		{
		case MSG_TIMED_OUT:
		case RECEIVE_ERROR:
		case SEND_ERROR:
		case OK:
			break;

		default:
			goto end_of_epc_handle_requests;
			break;
		}

		fprintf( stderr, "epc_handle_requests#sql code: %ld\n", (long)call.sqlcode );

		switch( call.sqlcode )
		{
		case -6556:
		case -6558:
		case -6559: /* dbms_pipe errors */
		case 0:
			break;

		default:
			goto end_of_epc_handle_requests;
			break;
		}
	}

end_of_epc_handle_requests:

	epc_debug( "epc_handle_requests#epc status: %s\n", get_error_str( call.epc_error ) );
	epc_debug( "epc_handle_requests#sql code: %ld\n", (long)call.sqlcode );

	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL COMMIT WORK RELEASE;

	epc_debug( "leaving epc_handle_requests\n" );
	return call.epc_error;
}

epc_info_t *epc_init( void )
{
	epc_info_t *epc_info = (epc_info_t*)malloc( sizeof(epc_info_t) );

	if ( epc_info == NULL )
		return NULL;

	epc_info->logon = NULL;
	epc_info->pipe = NULL;
	epc_info->num_interfaces = 0;
	epc_info->interfaces = NULL;

	return epc_info;
}

void epc_done( epc_info_t **epc_info )
{
	if ( *epc_info == NULL )
		return;

	if ( (*epc_info)->interfaces )
		free( (*epc_info)->interfaces );

	if ( (*epc_info)->pipe )
		free( (*epc_info)->pipe );

	free( *epc_info );
	*epc_info = NULL;
}

epc_error_t epc_set_logon( epc_info_t *epc_info, char *logon )
{
	if ( epc_info == NULL )
		return	MEMORY_ERROR;

	if ( logon == NULL )
	{
		if ( epc_info->logon != NULL )
			free( epc_info->logon );

		epc_info->logon = NULL;
		return OK;
	}

	epc_info->logon = (char*) realloc( epc_info->logon, strlen(logon) + 1 );
	if ( epc_info->logon == NULL )
		return	MEMORY_ERROR;

	strcpy( epc_info->logon, logon );

	return OK;
}

epc_error_t epc_set_pipe( epc_info_t *epc_info, char *pipe )
{
	if ( epc_info == NULL )
		return	MEMORY_ERROR;

	if ( pipe == NULL )
	{
		if ( epc_info->pipe != NULL )
			free( epc_info->pipe );

		epc_info->pipe = NULL;
		return OK;
	}

	epc_info->pipe = (char*) realloc( epc_info->pipe, strlen(pipe) + 1 );
	if ( epc_info->pipe == NULL )
		return	MEMORY_ERROR;

	strcpy( epc_info->pipe, pipe );

	return OK;
}

epc_error_t epc_add_interface( epc_info_t *epc_info, epc_interface_t *interface )
{
	if ( epc_info == NULL )
		return	MEMORY_ERROR;

	epc_info->num_interfaces++;
	epc_info->interfaces = 
		(epc_interface_t**)
			realloc(
				(void*)epc_info->interfaces,
				(size_t)(epc_info->num_interfaces * sizeof(epc_interface_t**))
			);

	if ( epc_info->interfaces == NULL )
	{
		epc_info->num_interfaces--;
		return	MEMORY_ERROR;
	}
	
	epc_info->interfaces[epc_info->num_interfaces - 1] = interface;

	return OK;
}

