/*
 * Filename   		: $Source$
 *
 * Creation date  : 25-AUG-1997
 *
 * Created by 		: Huub van der Wouden
 *
 * Company    		: Transfer Solutions bv
 *
 * --- Description -------------------------------------------------------
 * EPC functionality that requires interaction with the Oracle database.
 *
 * --- Revision History --------------------------------------------------
 * $Log$
 * Revision 1.8  1998/05/06 20:20:12  gpauliss
 * Added support for longs
 *
 * Revision 1.7  1998/02/19 17:10:02  gpauliss
 * <>
 *
 * Revision 1.6  1998/02/19 17:05:22  gpauliss
 * Test
 *
 * Revision 1.5  1998/02/19 16:41:06  gpauliss
 * Using dos filename conventions (8.3)
 *
 * Revision 1.4  1998/02/17 20:26:59  gpauliss
 * Changed EPC interface
 *
 * Revision 1.3  1998/02/03 12:55:56  gpauliss
 * Modified EPC_handle_requests for return type and wrong fprintf.
 *
 * Revision 1.2  1998/02/03 09:59:22  gpauliss
 * - Free up memory when needed
 * - Changed message protocol
 * - Removed global use of sqlca structure
 * - Added full error checking
 *
 * Revision 1.1  1998/01/25 15:18:07  gpauliss
 * Initial revision
 *
 *
 */
	/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#endif

/* force initialisation of any sqlca struct */
#define SQLCA_INIT

EXEC SQL BEGIN DECLARE SECTION;

EXEC SQL INCLUDE "epc_defs.h";  /* epc-specific type definitions */

EXEC SQL END DECLARE SECTION;

	/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include "epc_call.h"   /* server-side marshalling and call mechanism */
#include "epc_dbg.h"  /* trace and debug functionality */
#endif

/* =====================================================================
 *
 * LOCAL DEFINITIONS
 *
 *======================================================================*/

static
error_t 
get_parameters ( call_t * call )
/* ----------------------------------------------------------------------
 * Gets the function's parameters from the clients' request message,
 * and puts them in the call spec.
 *
 * return values:
 *		DATATYPE_UNKNOWN
 *		OK
 *		any return value from 
 *		-	add_string_parameter
 *		-	add_int_parameter
 *		-	add_float_parameter
 *		-	add_double_parameter
 * ----------------------------------------------------------------------*/
{

		/* declare a volatile struct: thread ready */

#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

	error_t retval = OK;

	EXEC SQL BEGIN DECLARE SECTION;
	int parameter_mode = 0;
	short parameter_mode_nl;
	int parameter_type = 0;
	short parameter_type_nl;
	int int_par = 0;
	short int_par_nl;
	long long_par = 0;
	short long_par_nl;
	float float_par = 0;
	short float_par_nl;
	double double_par = 0;
	short double_par_nl;

		/* GJP 21-JAN-1998 Put maximum number of characters for a VARCHAR2 in array */
	varchar string_par[MAX_STR_VAL_LEN] = { 0, "" };
	short string_par_nl;
	EXEC SQL END DECLARE SECTION;

	debug( "entering get_parameters\n" );

	for ( ; ; ) {

		EXEC SQL WHENEVER SQLERROR GOTO :no_more_parameters;

   		EXEC SQL EXECUTE
			BEGIN
				epc.request_get_parameter_info
				( 
					:parameter_mode:parameter_mode_nl
				,	:parameter_type:parameter_type_nl
				);

				IF	:parameter_mode:parameter_mode_nl IN ( epc.c_in, epc.c_inout )
				THEN
   					IF :parameter_type:parameter_type_nl = EPC.C_INT
   					THEN 
   						epc.request_get_parameter_value( :int_par:int_par_nl );
	   				ELSIF :parameter_type:parameter_type_nl = EPC.C_LONG
   					THEN 
   						epc.request_get_parameter_value( :long_par:long_par_nl );
	   				ELSIF :parameter_type:parameter_type_nl = EPC.C_FLOAT
   					THEN 
   						epc.request_get_parameter_value( :float_par:float_par_nl );
   					ELSIF :parameter_type:parameter_type_nl = EPC.C_DOUBLE
   					THEN 
	   					epc.request_get_parameter_value( :double_par:double_par_nl );
   					ELSIF :parameter_type:parameter_type_nl = EPC.C_STRING
   					THEN 
   						epc.request_get_parameter_value( :string_par:string_par_nl );
   					END IF;
				END IF;
			END;
   		END-EXEC;

		if ( parameter_mode_nl == -1 )
			parameter_mode = 0;

		if ( parameter_type_nl == -1 )
			parameter_type = 0;

		debug( "Parameter mode: %d; type: %d\n", parameter_mode, parameter_type );

		switch( parameter_type ) {
			case C_STRING:
				if ( string_par_nl == -1 )
					string_par.len = 0;
				string_par.arr[string_par.len] = '\0';
				retval = add_string_parameter( call, 
					(char*)string_par.arr, parameter_mode );
				break;

			case C_INT:
				if ( int_par_nl == -1 )
					int_par = 0;
				retval = add_int_parameter( call, 
					int_par, parameter_mode );
				break;

			case C_LONG:
				if ( long_par_nl == -1 )
					long_par = 0;
				retval = add_long_parameter( call, 
					long_par, parameter_mode );
				break;

			case C_FLOAT:
				if ( float_par_nl == -1 )
					float_par = 0;
				retval = add_float_parameter( call, 
					float_par, parameter_mode );
				break;

			case C_DOUBLE:
				if ( double_par_nl == -1 )
					double_par = 0;
				retval = add_double_parameter( call, 
					double_par, parameter_mode );
				break;

			default:
				retval = DATATYPE_UNKNOWN;
		}

		if ( retval != OK )
			goto end_of_get_parameters;
	} /* end while */

no_more_parameters:
    debug( "get_paramaters\nSQLCODE: %d\n", sqlca.sqlcode );

end_of_get_parameters:
	debug( "leaving get_parameters; retval = %d\n", retval );

	return retval;
}

static
error_t
receive_request( call_t * call )
/* ----------------------------------------------------------------------
 * Receives a clients' request from the specified database pipe
 *
 * return values:
 *		MSG_TIMED_OUT
 *		MSG_TOO_BIG
 *		MSG_INTERRUPTED
 *		RECEIVE_ERROR
 *		DATATYPE_UNKNOWN
 *		OK
 *		any return value from
 *              -       set_function
 *		-	get_parameters
 * ----------------------------------------------------------------------*/
{

		/* declare a volatile struct: thread ready */

#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
   	int retval = OK;
	varchar result_pipe[MAX_PIPE_NAME_LEN] = { 0, "" };     /* client-specific pipe for results  */
	short result_pipe_nl; /* null indicator */
	varchar interface[MAX_INTERFACE_NAME_LEN] = { 0, "" };
	short interface_nl; /* null indicator */
   	varchar function_name[MAX_FUNC_NAME_LEN] = { 0, "" };
	short function_name_nl; /* null indicator */
	int function_type = 0;
	short function_type_nl; /* null indicator */
	EXEC SQL END DECLARE SECTION;

	debug( "entering receive_request\n" );

	EXEC SQL WHENEVER SQLERROR GOTO receive_error;
	EXEC SQL EXECUTE
   		BEGIN
     		:retval := 
				epc.request_get_header
				( 
					:result_pipe:result_pipe_nl
				,	:interface:interface_nl
				,	:function_name:function_name_nl
				,	:function_type:function_type_nl
				);
		END;
	END-EXEC;

	switch( retval )
	{
	case 1: 
		retval = MSG_TIMED_OUT; 
		goto end_of_receive_request;
		break;
	case 2: 
		retval = MSG_TOO_BIG; 
		goto end_of_receive_request;
		break;
	case 3: 
		retval = MSG_INTERRUPTED; 
		goto end_of_receive_request;
		break;
	case 0:
		if ( result_pipe_nl == -1 )
			result_pipe.len = 0;
		result_pipe.arr[result_pipe.len] = '\0';

		if ( interface_nl == -1 )
			interface.len = 0;
		interface.arr[interface.len] = '\0';

		if ( function_name_nl == -1 )
			function_name.len = 0;
		function_name.arr[function_name.len] = '\0';

		if ( function_type_nl == -1 ) /* should not happen */
			function_type = -1;

		retval = set_function( call, (char *) result_pipe.arr, (char *) function_name.arr, function_type );
		if ( retval != OK )
			goto end_of_receive_request;

		retval = get_parameters( call );
		if ( retval != OK )
			goto end_of_receive_request;

		print_call( call );
		goto end_of_receive_request;
		break;

	default:
		/* ?? */
		retval = RECEIVE_ERROR;
		goto end_of_receive_request;
	}

receive_error:
    debug( "receive_request\nSQLCODE: %d\n", sqlca.sqlcode );
	retval = RECEIVE_ERROR;

end_of_receive_request:
	debug( "leaving receive_request; retval = %d\n", retval );
	return retval;
}

static
error_t
pack_value ( int type, void * value )
/* ----------------------------------------------------------------------
 * Pack a value in the message buffer
 *
 * return values:
 *		SEND_ERROR
 *		DATATYPE_UNKNOWN
 *		OK
 * ----------------------------------------------------------------------*/
{

#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

	error_t retval = OK;

	EXEC SQL BEGIN DECLARE SECTION;
	const int epc_type = type;
  	char * str_val = "";
  	int int_val = 0;
  	long long_val = 0;
  	float float_val = 0;
  	double double_val = 0;
	EXEC SQL END DECLARE SECTION;

	debug( "entering pack_value\n" );

  	switch( type ) {
  		case C_STRING:
  			str_val = (char *) value;
  			debug( "pack_value: str_val = %s\n", str_val );
  			break;
		case C_INT:
			int_val = * (int *) value;
			debug( "pack_value: int_val = %d\n", int_val );
			break;
		case C_LONG:
			long_val = * (long *) value;
			debug( "pack_value: long_val = %ld\n", long_val );
			break;
		case C_FLOAT:
			float_val = * (float *) value;
			debug( "pack_value: float_val = %f\n", float_val );
			break;
		case C_DOUBLE:
			double_val = * (double *) value;
			debug( "pack_value: double_val = %lf\n", double_val );
			break;
	   default:
			debug( "unknown parameter type %d...\n", type );
			retval = DATATYPE_UNKNOWN;
			goto end_of_pack_value;
	}

		/* Passing a whole block is usually more efficient for Oracle */

	EXEC SQL WHENEVER SQLERROR GOTO send_error;
  	EXEC SQL EXECUTE
  	BEGIN
		IF	:epc_type = epc.c_string
		THEN
			epc.result_set_parameter_value( :str_val );
    		ELSIF	:epc_type = epc.c_int
  		THEN
			epc.result_set_parameter_value( :int_val );
    		ELSIF	:epc_type = epc.c_long
  		THEN
			epc.result_set_parameter_value( :long_val );
		ELSIF	:epc_type = epc.c_float
		THEN
			epc.result_set_parameter_value( :float_val );
		ELSIF	:epc_type = epc.c_double
		THEN
			epc.result_set_parameter_value( :double_val );
		END IF;
	END;
	END-EXEC;

		/* everything OK */
	goto end_of_pack_value;

send_error:
	retval = SEND_ERROR;

end_of_pack_value:
	debug( "leaving pack_value; retval = %d\n", retval );
	return retval;
}

static
error_t
send_result ( error_t status, call_t * call )
/* ----------------------------------------------------------------------
 * Packs the result of the call as specified by the call spec and the
 * status of the call, into a message, and sends it through the specified
 * database pipe.
 *
 * return values:
 *		status if not OK
 *		return value of pack_value if not OK
 *		MSG_TIMED_OUT
 *		MSG_INTERRUPTED
 *		OK
 *		SEND_ERROR
 * ----------------------------------------------------------------------*/
{
#define SQLCA_INIT
#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

 	int i;

	EXEC SQL BEGIN DECLARE SECTION;
    int retval = OK;
  	int exec_status;
	const char *result_pipe = call->result_pipe;
	EXEC SQL END DECLARE SECTION;

	debug( "entering send_result\n" );
	debug( "sending result through pipe %s\n", result_pipe );
		
	/* First send status, stop if not OK */
	exec_status = (int) status;
	debug( "send_result: status = %d\n", exec_status );

	retval = pack_value( C_INT, &exec_status );

  	if ( status != OK )
  		retval = status;

	if ( retval != OK )
		goto end_of_send_result;

  	print_call( call );
  			
  	/* SEND OUT OR INOUT PARAMETER VALUES */
  	for ( i=0; i < call->num_parameters; i++ ) {
  		if ( call->parameters[i].mode == C_OUT || call->parameters[i].mode == C_INOUT ) {
  			debug( "send_result: sending parameter value\n" );
			retval = pack_value( call->parameters[i].type, call->parameters[i].value );
			if ( retval != OK )
				goto end_of_send_result;
		}
	}

	/* SEND FUNCTION RETURN VALUE IF THERE IS ONE */
	if ( call->return_value.type != C_VOID ) {
		debug( "send_result: sending return value\n" );
		retval = pack_value( call->return_value.type, call->return_value.value );
		if ( retval != OK )
			goto end_of_send_result;
	}
	
	EXEC SQL WHENEVER SQLERROR GOTO send_error;
	EXEC SQL EXECUTE
	   BEGIN
			:retval := DBMS_PIPE.SEND_MESSAGE( :result_pipe );
		END;
	END-EXEC;

	switch( retval )
	{
	case 1: /* timed out */
		retval = MSG_TIMED_OUT;
		goto end_of_send_result;
	case 3: /* interrupted */;
		retval = MSG_INTERRUPTED;
		goto end_of_send_result;
	case 0: /* OK */
		retval = OK;
		goto end_of_send_result;
	default:
		break; /* goto send_error */
	}

send_error:
	retval = SEND_ERROR;

end_of_send_result:
	debug( "leaving send_result; retval = %d\n", retval );
	return retval;
}


static
char *
get_error_str( error_t err )
{
	switch( err ) {
		case OK:
			return "OK";
		case MSG_TIMED_OUT:
			return "MSG_TIMED_OUT";
		case MSG_TOO_BIG:
			return "MSG_TOO_BIG";
		case MSG_INTERRUPTED:
			return "MSG_INTERRUPTED";
		case RECEIVE_ERROR:
			return "RECEIVE_ERROR";
		case EXEC_ERROR:
			return "EXEC_ERROR";
		case MEMORY_ERROR:
			return "MEMORY_ERROR";
		case DATATYPE_UNKNOWN:
			return "DATATYPE_UNKNOWN";
		case FUNCTION_UNKNOWN:
			return "FUNCTION_UNKNOWN";
		case PARAMETER_MODE_UNKNOWN:
			return "PARAMETER_MODE_UNKNOWN";
		case SEND_ERROR:
			return "SEND_ERROR";
		default:
			return "Unknown error";
	}
}

/* =====================================================================
 *
 * EXPORTED FUNCTIONS
 *
 *======================================================================*/
 
error_t
EPC_handle_requests( request_pipe )
EXEC SQL BEGIN DECLARE SECTION;
char * request_pipe;
EXEC SQL END DECLARE SECTION;
/* ----------------------------------------------------------------------
 * Handles all requests received over the specified database pipe:
 * - receives a request message
 * - unpacks the specifications of the requested call
 * - executes the call
 * - packs status and results of the call
 * - sends back the results
 * ----------------------------------------------------------------------*/
{
#ifdef SQLCA
#undef SQLCA
#endif

EXEC SQL INCLUDE sqlca;

	call_t call = CALL_INIT;
	error_t retval = OK;

	debug( "entering EPC_handle_requests\n" );

	if ( request_pipe != NULL ) {

		EXEC SQL WHENEVER SQLERROR GOTO end_of_EPC_handle_requests;
		EXEC SQL EXECUTE
			BEGIN
				epc.set_request_pipe( :request_pipe );
			END;
		END-EXEC;

	}

	for( ;; ) { 

		switch( retval = receive_request( &call ) ) {
			case OK:
				retval = exec_call( &call );
				retval = send_result( retval, &call );
				debug( "handle_requests: retval = %d\n", retval );
				break;

			case FUNCTION_UNKNOWN:
			case DATATYPE_UNKNOWN:
				/* message has the wrong format!? - notify client as well */
				debug( "ERROR in receiving message: '%s'\n", get_error_str( retval ) );
				retval = send_result( retval, &call );
				break;

			default:
				/* Can not report back to client */
				debug( "ERROR in receiving message: '%s'\n", get_error_str( retval ) );
				break;
		}

		free_call( &call );
	}

end_of_EPC_handle_requests:
	debug( "leaving EPC_handle_requests; retval = %d\n", retval );
	return retval;
}

